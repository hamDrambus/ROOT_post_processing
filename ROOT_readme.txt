---------------------- -------------------- --------------------- ------------------- window_width: --------------------------|

0) Installing of the ROOT on windows follows the standard guide as far as I remember.

1) I used root_v5.34.34 and ran scripts in the root.exe via .L command. (before launching vsvars32.bat run is required)

2) In order to compile c++ code with root as library in visual studio, some settings are required:
//"root compile as library visual studio" in google-> http://www.pp.rhul.ac.uk/~connelly/tutorial/
It is not checked that all of the following steps are required. 'root' is the path to ROOT installation
	1) Add 'root\include' to Project Preferences->Configuration Properties->Include Directories,
	'root\lib' and 'root\bin' to Configuration Properties->Library Directories,
	source directory for user code (if is in not default vs folder) to Configuration Properties->Source Directories

	2) Add 'root\include' to c/c++->General->Additional Include Directories
	
	3) Add _CRT_SECURE_NO_WARNINGS to c/c++->Preprocessor->Preprocessor Definitions

	4) Add 'root\include\w32pragma.h' to c/c++->Advanced->Forced Include Files

	5) Add 'root\lib' and 'root\bin' to Linker->General->Additional Library Directories

	6) Add 'root\lib\*.lib' to Linker->Input->Additional Dependencies

3) check code:

#include <TApplication.h>
#include <TCanvas.h>
#include <TF1.h>


int main(int argc, char *argv[])
{
	int n_par = 0;
	char **f = NULL;
	TApplication* app = new TApplication("test_app",&n_par,f);
	TCanvas* c1 = new TCanvas("test", "test_title", 800, 500);
	TF1 *func = new TF1("test_func", "sin(x)+5*x", 0, 10);
	func->Draw();
	app->Run();
	delete app;
	return 0;
}

/////////// Setups for eclipse IDE:
Setups:
C/C++ Build->Settings->
    GCC C++ Compiler->
	->Dialect->Other dialect flags: -std=c++11
	->Preprocessor->-D: NDEBUG
			    R__HAVE_CONFIG
	->Includes: /home/frolov/Software/root_v6.14.06/build/include
		    /home/frolov/Documents/Post_processor/include
	->Miscellaneous: -fPIC -pthread
    GCC C++ Linker->
	->General: -pthread
	->Libraries: Gui
Core
RIO
Net
Hist
Graf
Graf3d
Gpad
Tree
Rint
Postscript
Matrix
Physics
MathCore
Thread
MultiProc
Geom
m
Spectrum
Thread
	/home/frolov/Software/root_v6.14.06/build/lib
/home/frolov/Documents/Post_processor/include
	->Miscellaneous->Linker flags: -m64 -fPIC -fsigned-char -pipe -std=c++11

C/C++ General->Paths and Symbols->
    ->Source Location

4) For interactive program (Linux):
    1) Dictionary must be generated for CINT (c++ interpretator) to be able to use new code. Dictionary files (_dict.h _dict.cpp and dict.pcm) are generated by rootcint.
    It's convinient to call it automatically at pre-build step from IDE of choice. For that add 
	  rootcint -f ${CWD}/../../source/post_processor_dict.cpp -c -I${CWD}/../../include AllExperimentsResults.h AllRunsResults.h AnalysisManager.h AnalysisStates.h CalibrationInfo.h EventCut.h ExperimentArea.h FunctionWrapper.h GlobalDefinitions.h GlobalParameters.h GraphicOutputManager.h HistogramSetups.h Polynom2Order.h PolynomialFit.h PostProcessor.h Savitzky_Golay_filter.h SignalOperations.h SingleRunData.h SingleRunResults.h main.h LinkDef.h
	LinkDef.h must be the last. About it and the process itself in the links below:
	[https://root.cern.ch/interacting-shared-libraries-rootcint] - General overview.
	[https://root.cern.ch/root/html534/guides/users-guide/AddingaClass.html] - In detail about LinkDef.h
	The fact that adding -I$(PATH) is possible is from "rootcint -h" output and the web.
    Since rootcinc could not build dictionary for std::deque<TSomeROOTClass> because, I suspect, of internal bug, I had to turn off linking all classes (#pragma link C++ all class;)
    and instead link only classes defined by me using "#pragma link C++ defined_in "IncludeFile.h";"
	
!!! 2) {std::function, override, = default} are not supported in CINT! (compiled lambda functoins are ok, but they can't be typedefined, or used as parameters via std::function)
    
    3) Make sure that the flags used for compiling shared library (passed to gcc) to be loaded in ROOT are the same (except optimization, debug level and -w (warnings) flags)
    as those used by ACLIC (ROOT) when compileing interpreted code with ".L name.cpp+". The flags which are used by ROOT can be viewed using gSystem methods (from ROOT itself)
    (see TSystem class ref.):
	gSystem->GetMakeSharedLib() //describes with which command compiler is called. Some environment variables such as $IncludePath are controllable
	//(via. gSystem->SetIncludePath("-I$ROOTSYS/include -I/your/path/to/include") or gInterpreter->AddIncludePath("/your/path/to/include");)
	//flags starting with -w may be ignored as they controll warnings.
	//$Opt are debugging and optimization flags which can be determined from
	gSystem->GetFlagsOpt()   //optimization and
	gSystem->GetFlagsDebug() //debug level
	//Again, debug, warning and optimization options for compiling user library may do not match ROOT's ones.
	
    4) build shared (.so) library with right flags. (do not forget to include dictionary.cpp file into build)
    
    5) In order to load library some directories must be set withing ROOT (see loader.cpp):
	gSystem->SetIncludePath("-I$ROOTSYS/include -I/...../include -I/...../source -I/...../build/Debug");//where /Debug contains user library from step (4) 
	gSystem->AddDynamicPath("/...../build/Debug"); //so root can find "libtarget.so"
	gSystem->AddDynamicPath("/...../source"); //assuming dictionary.cpp was generated in source directory, root will need to load some other generated by rootcint files (.pcm).
	
    6) gSystem->Load("libtarget.so"); //integrates used code and CINT. There is still some problem with namspaces, for example typing "SignalOperations::integrate(...);"
    will fail with unresolved error, yet dict.cpp contains names of functions which indicates they were linked. Use the following trick:
      Type SignalO and the TAB so ROOT autocopletes the namespace. After :: also press TAB and choose method to use. In this way there's no resolving errors. 
    
	
